<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÅ 3D ÎìúÎ°† AI ÎåÄÏ†Ñ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ - Í≥†ÎèÑÌôî</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* HP Î∞î Ïä§ÌÉÄÏùº */
        .hp-bar-container {
            position: absolute;
            width: 350px;
            height: 45px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 25px;
            padding: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        .hp-bar-fill {
            height: 100%;
            border-radius: 20px;
            transition: width 0.3s ease, background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            box-shadow: inset 0 2px 10px rgba(255, 255, 255, 0.3);
        }
        
        #player-hp-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #ai-hp-bar {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Ï†ïÎ≥¥ Ìå®ÎÑê */
        #info-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 100;
            min-width: 300px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(74, 222, 128, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #info-panel h2 {
            font-size: 20px;
            margin-bottom: 12px;
            color: #4ade80;
            border-bottom: 2px solid #4ade80;
            padding-bottom: 8px;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        
        .stat {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat .label {
            color: #94a3b8;
        }
        
        .stat .value {
            color: #4ade80;
            font-weight: bold;
        }
        
        /* Ìã∞Ïñ¥ ÌëúÏãú */
        .tier-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 13px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        /* Î†àÎ≤® & Í≤ΩÌóòÏπò Î∞î */
        .exp-bar-container {
            width: 100%;
            height: 18px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .exp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        
        /* Ï†êÏàò Ìå®ÎÑê */
        #score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #score-panel h2 {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 12px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .score-value {
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            margin: 10px 0;
        }
        
        /* ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù */
        #difficulty-selector {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 15px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(147, 51, 234, 0.5);
            min-width: 220px;
        }
        
        #difficulty-selector h3 {
            color: #a78bfa;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .difficulty-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .difficulty-btn.easy {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .difficulty-btn.normal {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }
        
        .difficulty-btn.hard {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .difficulty-btn.extreme {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .difficulty-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
        }
        
        .difficulty-btn.active {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê */
        #upgrade-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 18px;
            border-radius: 15px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(147, 51, 234, 0.5);
            max-width: 320px;
        }
        
        #upgrade-panel h3 {
            color: #a78bfa;
            margin-bottom: 12px;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(167, 139, 250, 0.5);
        }
        
        .upgrade-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 6px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .upgrade-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(167, 139, 250, 0.3);
        }
        
        .upgrade-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .upgrade-cost {
            color: #ffd700;
            font-weight: bold;
        }
        
        /* Ï°∞ÏûëÎ≤ï */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 18px;
            border-radius: 15px;
            font-size: 13px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(96, 165, 250, 0.3);
        }
        
        #controls h3 {
            margin-bottom: 12px;
            color: #60a5fa;
            text-shadow: 0 0 10px rgba(96, 165, 250, 0.5);
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }
        
        /* ÏïåÎ¶º Î©îÏãúÏßÄ */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 25px 50px;
            border-radius: 15px;
            font-size: 28px;
            font-weight: bold;
            z-index: 2000;
            display: none;
            text-align: center;
            border: 3px solid #4ade80;
            box-shadow: 0 10px 50px rgba(74, 222, 128, 0.5);
            animation: notificationPulse 0.5s ease-in-out;
        }
        
        @keyframes notificationPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Î°úÎî© */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 28px;
            z-index: 200;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.8);
        }
        
        /* Ïó∞Í≤∞ ÏÉÅÌÉú */
        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-300px);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 13px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-dot.green {
            background: #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.8);
        }
        
        .status-dot.red {
            background: #ef4444;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.8);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }
        
        /* ÎØ∏ÎãàÎßµ */
        #minimap {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 100;
        }
        
        #minimap canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="loading">üöÅ Í≤åÏûÑ Î°úÎî© Ï§ë...</div>
        
        <!-- ÌîåÎ†àÏù¥Ïñ¥ HP Î∞î -->
        <div id="player-hp-bar" class="hp-bar-container">
            <div class="hp-bar-fill" id="player-hp-fill" style="width: 100%; background: linear-gradient(90deg, #4ade80, #22c55e);">
                <span id="player-hp-text">100 / 100</span>
            </div>
        </div>
        
        <!-- AI HP Î∞î -->
        <div id="ai-hp-bar" class="hp-bar-container">
            <div class="hp-bar-fill" id="ai-hp-fill" style="width: 100%; background: linear-gradient(90deg, #ef4444, #dc2626);">
                <span id="ai-hp-text">AI: 100 / 100</span>
            </div>
        </div>
        
        <!-- Ï†ïÎ≥¥ Ìå®ÎÑê -->
        <div id="info-panel">
            <h2>üë§ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥</h2>
            <div class="stat">
                <span class="label">Î†àÎ≤®:</span>
                <span class="value" id="player-level">1</span>
            </div>
            <div class="stat">
                <span class="label">Ìã∞Ïñ¥:</span>
                <span class="tier-badge" id="player-tier">Bronze</span>
            </div>
            <div class="stat">
                <span class="label">ÏΩîÏù∏:</span>
                <span class="value" id="player-coins">0 üí∞</span>
            </div>
            <div class="exp-bar-container">
                <div class="exp-bar-fill" id="exp-bar" style="width: 0%;"></div>
            </div>
            <div class="stat" style="font-size: 12px; margin-top: 5px;">
                <span id="exp-text">0 / 100 EXP</span>
            </div>
        </div>
        
        <!-- Ï†êÏàò Ìå®ÎÑê -->
        <div id="score-panel">
            <h2>üèÜ Ï†ÑÌà¨ Í∏∞Î°ù</h2>
            <div class="stat">
                <span class="label">ÌÇ¨:</span>
                <span class="value" id="kill-count">0</span>
            </div>
            <div class="stat">
                <span class="label">Ï†êÏàò:</span>
                <span class="score-value" id="score-value">0</span>
            </div>
        </div>
        
        <!-- ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù -->
        <div id="difficulty-selector">
            <h3>üéØ AI ÎÇúÏù¥ÎèÑ</h3>
            <button class="difficulty-btn easy" data-difficulty="easy">
                üü¢ Easy
            </button>
            <button class="difficulty-btn normal active" data-difficulty="normal">
                üîµ Normal
            </button>
            <button class="difficulty-btn hard" data-difficulty="hard">
                üü† Hard
            </button>
            <button class="difficulty-btn extreme" data-difficulty="extreme">
                üî¥ Extreme
            </button>
        </div>
        
        <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê -->
        <div id="upgrade-panel">
            <h3>‚ö° ÏóÖÍ∑∏Î†àÏù¥Îìú</h3>
            <div class="upgrade-item" data-type="speed">
                <span>üöÄ ÏÜçÎèÑ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 üí∞</span>
            </div>
            <div class="upgrade-item" data-type="armor">
                <span>üõ°Ô∏è Î∞©Ïñ¥Î†• Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 üí∞</span>
            </div>
            <div class="upgrade-item" data-type="damage">
                <span>‚öîÔ∏è Í≥µÍ≤©Î†• Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 üí∞</span>
            </div>
            <div class="upgrade-item" data-type="fire_rate">
                <span>‚ö° Î∞úÏÇ¨ÏÜçÎèÑ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 üí∞</span>
            </div>
        </div>
        
        <!-- Ï°∞ÏûëÎ≤ï -->
        <div id="controls">
            <h3>‚å®Ô∏è Ï°∞ÏûëÎ≤ï</h3>
            <div>
                <span class="key">W</span> Ï†ÑÏßÑ |
                <span class="key">S</span> ÌõÑÏßÑ |
                <span class="key">A</span> Ï¢åÏ∏° |
                <span class="key">D</span> Ïö∞Ï∏°
            </div>
            <div style="margin-top: 10px;">
                <span class="key">Space</span> ÏÉÅÏäπ |
                <span class="key">Shift</span> ÌïòÍ∞ï
            </div>
            <div style="margin-top: 10px;">
                <span class="key">F</span> ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ üöÄ
            </div>
        </div>
        
        <!-- Ïó∞Í≤∞ ÏÉÅÌÉú -->
        <div id="status">
            <span class="status-dot red"></span>
            <span id="status-text">ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...</span>
        </div>
        
        <!-- ÏïåÎ¶º -->
        <div id="notification"></div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        console.log('üéÆ 3D ÎìúÎ°† AI ÎåÄÏ†Ñ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ - Í≥†ÎèÑÌôî Î≤ÑÏ†Ñ ÏãúÏûë!');
        console.log('‚ú® ÏÉàÎ°úÏö¥ Í∏∞Îä•: Î¨ºÎ¶¨ ÏóîÏßÑ, ÎåÄÌòï Îßµ, AI Í≥†ÎèÑÌôî, Í∑∏ÎûòÌîΩ Í∞úÏÑ†');
        
        // ========== Ï†ÑÏó≠ Î≥ÄÏàò ==========
        let scene, camera, renderer;
        let playerDrone, aiDrone;
        let obstacles = [];
        let missiles = {};
        let explosions = [];
        let particles = [];
        let websocket;
        let isConnected = false;
        let clientId, aiDroneId;
        let currentDifficulty = 'normal';
        
        // ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞
        let playerData = {
            position: { x: 0, y: 15, z: 60 },
            velocity: { x: 0, y: 0, z: 0 },
            hp: 100,
            max_hp: 100,
            level: 1,
            exp: 0,
            coins: 0,
            tier: 'Bronze'
        };
        
        // AI Îç∞Ïù¥ÌÑ∞
        let aiData = {
            position: { x: -10, y: 15, z: -10 },
            hp: 100,
            max_hp: 100,
            behavior_mode: 'aggressive'
        };
        
        // Í≤åÏûÑ ÏÑ§Ï†ï (Ìñ•ÏÉÅÎêú Î¨ºÎ¶¨)
        let keys = {};
        const MOVE_SPEED = 0.4;
        const MAX_SPEED = 1.2;
        const ACCELERATION = 0.07;
        const DRAG = 0.93;
        const MAP_SIZE = 200;
        
        // FPS
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // ========== Three.js Ï¥àÍ∏∞Ìôî (Í≥†ÎèÑÌôî) ==========
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);
            scene.fog = new THREE.Fog(0x0a0e27, 80, 180);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                80,  // Îçî ÎÑìÏùÄ ÏãúÏïºÍ∞Å
                window.innerWidth / window.innerHeight,
                0.1,
                500
            );
            camera.position.set(0, 25, 50);
            camera.lookAt(0, 15, 0);
            
            // Renderer (Í≥†ÌíàÏßà)
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Í≥†Í∏â Ï°∞Î™Ö ÏãúÏä§ÌÖú
            setupLighting();
            
            // Î∞îÎã• (Í∞úÏÑ†Îêú ÌÖçÏä§Ï≤ò)
            createGround();
            
            // ÎìúÎ°† ÏÉùÏÑ±
            createPlayerDrone();
            createAIDrone();
            
            // ÌååÌã∞ÌÅ¥ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
            initParticleSystem();
            
            window.addEventListener('resize', onWindowResize);
            
            console.log('‚úÖ Three.js Ï¥àÍ∏∞Ìôî ÏôÑÎ£å! (Í≥†ÎèÑÌôî)');
        }
        
        function setupLighting() {
            // ÌôòÍ≤ΩÍ¥ë
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(ambientLight);
            
            // Ï£º Î∞©Ìñ•Í¥ë (ÌÉúÏñë)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.001;
            scene.add(sunLight);
            
            // Î≥¥Ï°∞ Ï±ÑÏõÄÍ¥ë
            const fillLight = new THREE.DirectionalLight(0x4466ff, 0.5);
            fillLight.position.set(-50, 30, -50);
            scene.add(fillLight);
            
            // Ïä§ÌåÄÌéëÌÅ¨ Î∂ÑÏúÑÍ∏∞ Ìè¨Ïù∏Ìä∏ ÎùºÏù¥Ìä∏ (Ïó¨Îü¨ Í∞ú)
            const pointLightPositions = [
                { pos: [30, 20, 30], color: 0xff6b35, intensity: 3 },
                { pos: [-40, 25, -40], color: 0x4ecdc4, intensity: 3 },
                { pos: [60, 15, -60], color: 0xf39c12, intensity: 2.5 },
                { pos: [-60, 18, 60], color: 0x9b59b6, intensity: 2.5 },
                { pos: [0, 30, 0], color: 0xe74c3c, intensity: 4 }
            ];
            
            pointLightPositions.forEach(({ pos, color, intensity }) => {
                const light = new THREE.PointLight(color, intensity, 80);
                light.position.set(...pos);
                scene.add(light);
                
                // ÎùºÏù¥Ìä∏ Ìó¨Ìçº (ÏãúÍ∞ÅÏ†Å Ìö®Í≥º)
                const sphereGeom = new THREE.SphereGeometry(0.5, 8, 8);
                const sphereMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                sphere.position.set(...pos);
                scene.add(sphere);
            });
        }
        
        function createGround() {
            const groundSize = MAP_SIZE;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 50, 50);
            
            // ÏßÄÌòï Í≥†ÎèÑ Î≥ÄÌôî (ÏïΩÍ∞ÑÏùò Ïñ∏Îçï)
            const positions = groundGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                const height = Math.sin(x * 0.02) * Math.cos(z * 0.02) * 2;
                positions.setY(i, height);
            }
            positions.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                roughness: 0.9,
                metalness: 0.1,
                flatShading: false
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Í∑∏Î¶¨Îìú (Îçî ÌÅ∞ Îßµ)
            const gridHelper = new THREE.GridHelper(groundSize, 40, 0x4ecdc4, 0x2d3561);
            gridHelper.position.y = 0.1;
            scene.add(gridHelper);
        }
        
        function createPlayerDrone() {
            const bodyGeometry = new THREE.BoxGeometry(2.5, 0.6, 2.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4ade80,
                emissive: 0x2dd4bf,
                emissiveIntensity: 0.4,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            // ÌîÑÎ°úÌé†Îü¨ (Í∞úÏÑ†Îêú ÎîîÏûêÏù∏)
            const propellerGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.12, 12);
            const propellerMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.2
            });
            
            const propellerPositions = [
                { x: 1.2, z: 1.2 },
                { x: -1.2, z: 1.2 },
                { x: 1.2, z: -1.2 },
                { x: -1.2, z: -1.2 }
            ];
            
            playerDrone = new THREE.Group();
            playerDrone.add(body);
            
            propellerPositions.forEach(pos => {
                const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                propeller.position.set(pos.x, 0.5, pos.z);
                propeller.userData.rotationSpeed = Math.random() * 0.6 + 0.6;
                playerDrone.add(propeller);
                
                // ÌîÑÎ°úÌé†Îü¨ Í¥ëÏÑ† Ìö®Í≥º
                const lightGeom = new THREE.SphereGeometry(0.3, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0x4ade80,
                    transparent: true,
                    opacity: 0.5
                });
                const lightSphere = new THREE.Mesh(lightGeom, lightMat);
                lightSphere.position.set(pos.x, 0.5, pos.z);
                playerDrone.add(lightSphere);
            });
            
            // Ìè¨Ïù∏Ìä∏ ÎùºÏù¥Ìä∏ (ÎìúÎ°† Ï°∞Î™Ö)
            const droneLight = new THREE.PointLight(0x4ade80, 2, 15);
            droneLight.position.set(0, 0, 0);
            playerDrone.add(droneLight);
            
            playerDrone.position.set(playerData.position.x, playerData.position.y, playerData.position.z);
            scene.add(playerDrone);
        }
        
        function createAIDrone() {
            const bodyGeometry = new THREE.BoxGeometry(2.5, 0.6, 2.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xef4444,
                emissive: 0xdc2626,
                emissiveIntensity: 0.4,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            const propellerGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.12, 12);
            const propellerMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xef4444,
                emissiveIntensity: 0.2
            });
            
            const propellerPositions = [
                { x: 1.2, z: 1.2 },
                { x: -1.2, z: 1.2 },
                { x: 1.2, z: -1.2 },
                { x: -1.2, z: -1.2 }
            ];
            
            aiDrone = new THREE.Group();
            aiDrone.add(body);
            
            propellerPositions.forEach(pos => {
                const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                propeller.position.set(pos.x, 0.5, pos.z);
                propeller.userData.rotationSpeed = Math.random() * 0.6 + 0.6;
                aiDrone.add(propeller);
                
                const lightGeom = new THREE.SphereGeometry(0.3, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0xef4444,
                    transparent: true,
                    opacity: 0.5
                });
                const lightSphere = new THREE.Mesh(lightGeom, lightMat);
                lightSphere.position.set(pos.x, 0.5, pos.z);
                aiDrone.add(lightSphere);
            });
            
            const droneLight = new THREE.PointLight(0xef4444, 2, 15);
            droneLight.position.set(0, 0, 0);
            aiDrone.add(droneLight);
            
            aiDrone.position.set(aiData.position.x, aiData.position.y, aiData.position.z);
            scene.add(aiDrone);
        }
        
        // ========== Ïû•Ïï†Î¨º ÏÉùÏÑ± (ÌôïÏû•Îêú Îßµ) ==========
        function createObstacles(obstaclesData) {
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            
            obstaclesData.forEach(obsData => {
                let obstacle;
                const type = obsData.type;
                const position = obsData.position;
                const size = obsData.size;
                const color = obsData.color || 0xb45309;
                
                if (type === 'gear') {
                    // ÌÜ±ÎãàÎ∞îÌÄ¥
                    const geometry = new THREE.CylinderGeometry(size[0], size[0], size[1], 20);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.95,
                        roughness: 0.2,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                    // ÌÜ±Îãà Ï∂îÍ∞Ä
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const toothGeom = new THREE.BoxGeometry(0.4, size[1] * 1.1, 1);
                        const tooth = new THREE.Mesh(toothGeom, material);
                        const radius = size[0] + 0.4;
                        tooth.position.set(
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        );
                        tooth.rotation.y = angle;
                        obstacle.add(tooth);
                    }
                    
                } else if (type === 'pipe') {
                    // ÌååÏù¥ÌîÑ
                    const geometry = new THREE.CylinderGeometry(size[0], size[0], size[1], 12);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.85,
                        roughness: 0.3
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                    if (obsData.rotation === 90) {
                        obstacle.rotation.z = Math.PI / 2;
                    } else if (obsData.rotation === 45) {
                        obstacle.rotation.z = Math.PI / 4;
                    }
                    
                } else if (type === 'tower') {
                    // Ï§ëÏïô ÌÉÄÏõå
                    const geometry = new THREE.CylinderGeometry(size[0] * 0.8, size[0], size[1], 8);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.7,
                        roughness: 0.4
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                } else if (type === 'cube') {
                    // ÌÅêÎ∏å
                    const geometry = new THREE.BoxGeometry(...size);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.6,
                        roughness: 0.5
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.rotation.y = Math.random() * Math.PI;
                    
                } else if (type === 'ring') {
                    // ÎßÅ
                    const geometry = new THREE.TorusGeometry(size[0], size[2], 16, 32);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: color,
                        emissiveIntensity: 0.3
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.rotation.x = Math.PI / 2;
                    
                } else if (type === 'crystal') {
                    // ÌÅ¨Î¶¨Ïä§ÌÉà
                    const geometry = new THREE.ConeGeometry(size[0], size[1], 6);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.3,
                        roughness: 0.1,
                        emissive: color,
                        emissiveIntensity: 0.6,
                        transparent: true,
                        opacity: 0.8
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                } else if (type === 'platform') {
                    // ÌîåÎû´Ìèº
                    const geometry = new THREE.BoxGeometry(...size);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.8,
                        roughness: 0.6
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                } else if (type === 'spike') {
                    // Ïä§ÌååÏù¥ÌÅ¨
                    const geometry = new THREE.ConeGeometry(size[0], size[1], 4);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                }
                
                if (obstacle) {
                    obstacle.position.set(...position);
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    obstacle.userData.rotationSpeed = obsData.rotation_speed || Math.random() * 0.01 + 0.005;
                    obstacle.userData.originalData = obsData;
                    
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                }
            });
            
            console.log(`‚úÖ ${obstacles.length}Í∞úÏùò Ïû•Ïï†Î¨º ÏÉùÏÑ± ÏôÑÎ£å!`);
        }
        
        // ========== ÌååÌã∞ÌÅ¥ ÏãúÏä§ÌÖú ==========
        function initParticleSystem() {
            particles = [];
        }
        
        function createTrailParticle(position, color) {
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(...position);
            particle.userData.life = 30;
            particle.userData.maxLife = 30;
            
            scene.add(particle);
            particles.push(particle);
        }
        
        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.userData.life--;
                const progress = 1 - (particle.userData.life / particle.userData.maxLife);
                
                particle.scale.set(1 - progress * 0.5, 1 - progress * 0.5, 1 - progress * 0.5);
                particle.material.opacity = 1 - progress;
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
        }
        
        // ========== ÎØ∏ÏÇ¨Ïùº ÏÉùÏÑ± (Í∞úÏÑ†) ==========
        function createMissile(missileData) {
            const geometry = new THREE.SphereGeometry(0.4, 12, 12);
            const isPlayerMissile = !missileData.owner_id.includes('ai');
            
            const material = new THREE.MeshStandardMaterial({
                color: isPlayerMissile ? 0x4ade80 : 0xef4444,
                emissive: isPlayerMissile ? 0x22c55e : 0xff0000,
                emissiveIntensity: 0.7,
                metalness: 0.9,
                roughness: 0.1
            });
            
            const missile = new THREE.Mesh(geometry, material);
            missile.position.set(...missileData.position);
            
            // ÎØ∏ÏÇ¨Ïùº ÎùºÏù¥Ìä∏
            const missileLight = new THREE.PointLight(
                isPlayerMissile ? 0x4ade80 : 0xef4444,
                3,
                10
            );
            missileLight.position.set(0, 0, 0);
            missile.add(missileLight);
            
            // Íº¨Î¶¨ Ìö®Í≥º (Í∞úÏÑ†)
            const tailGeometry = new THREE.ConeGeometry(0.2, 1, 8);
            const tailMaterial = new THREE.MeshBasicMaterial({
                color: isPlayerMissile ? 0x66ff66 : 0xff6666,
                transparent: true,
                opacity: 0.7
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.rotation.x = Math.PI / 2;
            tail.position.z = -0.7;
            missile.add(tail);
            
            scene.add(missile);
            missiles[missileData.missile_id] = {
                mesh: missile,
                data: missileData
            };
        }
        
        // ========== Ìè≠Î∞ú Ïù¥ÌéôÌä∏ (Í≥†ÎèÑÌôî) ==========
        function createExplosion(position) {
            // Ï£º Ìè≠Î∞ú
            const geometry = new THREE.SphereGeometry(1.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1.0
            });
            
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.set(...position);
            explosion.userData.life = 40;
            explosion.userData.maxLife = 40;
            
            scene.add(explosion);
            explosions.push(explosion);
            
            // ÌååÌã∞ÌÅ¥ ÌååÌé∏ (Ï∂îÍ∞Ä)
            for (let i = 0; i < 15; i++) {
                const particleGeom = new THREE.SphereGeometry(0.2, 8, 8);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: [0xff6600, 0xff3300, 0xffaa00][Math.floor(Math.random() * 3)],
                    transparent: true,
                    opacity: 1.0
                });
                
                const particle = new THREE.Mesh(particleGeom, particleMat);
                particle.position.set(...position);
                
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize();
                
                particle.userData.velocity = direction.multiplyScalar(Math.random() * 0.5 + 0.3);
                particle.userData.life = Math.random() * 20 + 20;
                particle.userData.maxLife = particle.userData.life;
                
                scene.add(particle);
                explosions.push(particle);
            }
            
            // Ìè≠Î∞ú ÎùºÏù¥Ìä∏
            const explosionLight = new THREE.PointLight(0xff6600, 10, 20);
            explosionLight.position.set(...position);
            scene.add(explosionLight);
            
            setTimeout(() => {
                scene.remove(explosionLight);
            }, 100);
        }
        
        // ========== ÎØ∏ÏÇ¨Ïùº ÏóÖÎç∞Ïù¥Ìä∏ ==========
        function updateMissiles(missilesList) {
            const activeMissileIds = new Set(missilesList.map(m => m.missile_id));
            
            for (const missileId in missiles) {
                if (!activeMissileIds.has(missileId)) {
                    scene.remove(missiles[missileId].mesh);
                    delete missiles[missileId];
                }
            }
            
            missilesList.forEach(missileData => {
                if (missiles[missileData.missile_id]) {
                    const missile = missiles[missileData.missile_id];
                    missile.mesh.position.set(...missileData.position);
                    missile.mesh.rotation.z += 0.3;
                    
                    // ÎØ∏ÏÇ¨Ïùº Ìä∏Î†àÏùº
                    if (frameCount % 3 === 0) {
                        const color = missileData.owner_id.includes('ai') ? 0xff4444 : 0x44ff44;
                        createTrailParticle(missileData.position, color);
                    }
                } else {
                    createMissile(missileData);
                }
            });
        }
        
        // ========== Ìè≠Î∞ú Ïï†ÎãàÎ©îÏù¥ÏÖò ==========
        function updateExplosions() {
            explosions.forEach((explosion, index) => {
                explosion.userData.life--;
                const progress = 1 - (explosion.userData.life / explosion.userData.maxLife);
                
                // ÌååÌã∞ÌÅ¥ Ïù¥Îèô
                if (explosion.userData.velocity) {
                    explosion.position.add(explosion.userData.velocity);
                    explosion.userData.velocity.y -= 0.01;  // Ï§ëÎ†•
                }
                
                explosion.scale.set(1 + progress * 4, 1 + progress * 4, 1 + progress * 4);
                explosion.material.opacity = 1 - progress;
                
                if (explosion.userData.life <= 0) {
                    scene.remove(explosion);
                    explosions.splice(index, 1);
                }
            });
        }
        
        // ========== ÌÇ§Î≥¥Îìú ÏûÖÎ†• ==========
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'KeyF' && isConnected) {
                fireMissile();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // ========== ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ ==========
        function fireMissile() {
            const direction = [
                aiDrone.position.x - playerDrone.position.x,
                aiDrone.position.y - playerDrone.position.y,
                aiDrone.position.z - playerDrone.position.z
            ];
            
            const length = Math.sqrt(direction[0]**2 + direction[1]**2 + direction[2]**2);
            if (length > 0) {
                direction[0] /= length;
                direction[1] /= length;
                direction[2] /= length;
            }
            
            websocket.send(JSON.stringify({
                type: 'fire_missile',
                direction: direction
            }));
        }
        
        // ========== ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏ (Í∞úÏÑ†) ==========
        function updatePlayer() {
            if (keys['KeyW']) playerData.velocity.z -= ACCELERATION;
            if (keys['KeyS']) playerData.velocity.z += ACCELERATION;
            if (keys['KeyA']) playerData.velocity.x -= ACCELERATION;
            if (keys['KeyD']) playerData.velocity.x += ACCELERATION;
            if (keys['Space']) playerData.velocity.y += ACCELERATION * 0.8;
            if (keys['ShiftLeft'] || keys['ShiftRight']) playerData.velocity.y -= ACCELERATION * 0.8;
            
            const speed = Math.sqrt(
                playerData.velocity.x ** 2 + 
                playerData.velocity.y ** 2 + 
                playerData.velocity.z ** 2
            );
            if (speed > MAX_SPEED) {
                playerData.velocity.x = (playerData.velocity.x / speed) * MAX_SPEED;
                playerData.velocity.y = (playerData.velocity.y / speed) * MAX_SPEED;
                playerData.velocity.z = (playerData.velocity.z / speed) * MAX_SPEED;
            }
            
            playerData.position.x += playerData.velocity.x;
            playerData.position.y += playerData.velocity.y;
            playerData.position.z += playerData.velocity.z;
            
            // ÌôïÏû•Îêú Îßµ Í≤ΩÍ≥Ñ
            const boundary = MAP_SIZE / 2 - 5;
            playerData.position.x = Math.max(-boundary, Math.min(boundary, playerData.position.x));
            playerData.position.y = Math.max(3, Math.min(60, playerData.position.y));
            playerData.position.z = Math.max(-boundary, Math.min(boundary, playerData.position.z));
            
            playerData.velocity.x *= DRAG;
            playerData.velocity.y *= DRAG;
            playerData.velocity.z *= DRAG;
            
            if (playerDrone) {
                playerDrone.position.set(playerData.position.x, playerData.position.y, playerData.position.z);
                
                playerDrone.children.forEach(child => {
                    if (child.geometry && child.geometry.type === 'CylinderGeometry') {
                        child.rotation.y += child.userData.rotationSpeed || 0.4;
                    }
                });
                
                playerDrone.rotation.z = -playerData.velocity.x * 0.25;
                playerDrone.rotation.x = playerData.velocity.z * 0.25;
                
                // ÎìúÎ°† Ìä∏Î†àÏùº (Í∞ÄÎÅî)
                if (speed > 0.5 && frameCount % 5 === 0) {
                    createTrailParticle([playerData.position.x, playerData.position.y, playerData.position.z], 0x4ade80);
                }
            }
            
            // Ïπ¥Î©îÎùº (Î∂ÄÎìúÎü¨Ïö¥ Ï∂îÏ†Å)
            const cameraOffset = { x: 0, y: 20, z: 35 };
            const targetCameraX = playerData.position.x + cameraOffset.x;
            const targetCameraY = playerData.position.y + cameraOffset.y;
            const targetCameraZ = playerData.position.z + cameraOffset.z;
            
            camera.position.x += (targetCameraX - camera.position.x) * 0.1;
            camera.position.y += (targetCameraY - camera.position.y) * 0.1;
            camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
            
            camera.lookAt(playerData.position.x, playerData.position.y, playerData.position.z);
            
            if (isConnected && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'player_update',
                    position: [playerData.position.x, playerData.position.y, playerData.position.z],
                    velocity: [playerData.velocity.x, playerData.velocity.y, playerData.velocity.z]
                }));
            }
        }
        
        // ========== UI ÏóÖÎç∞Ïù¥Ìä∏ ==========
        function updateUI() {
            const playerHpPercent = (playerData.hp / playerData.max_hp) * 100;
            document.getElementById('player-hp-fill').style.width = playerHpPercent + '%';
            document.getElementById('player-hp-text').textContent = `${playerData.hp} / ${playerData.max_hp}`;
            
            const playerHpFill = document.getElementById('player-hp-fill');
            if (playerHpPercent > 60) {
                playerHpFill.style.background = 'linear-gradient(90deg, #4ade80, #22c55e)';
            } else if (playerHpPercent > 30) {
                playerHpFill.style.background = 'linear-gradient(90deg, #fbbf24, #f59e0b)';
            } else {
                playerHpFill.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
            }
            
            const aiHpPercent = (aiData.hp / aiData.max_hp) * 100;
            document.getElementById('ai-hp-fill').style.width = aiHpPercent + '%';
            document.getElementById('ai-hp-text').textContent = `AI [${aiData.behavior_mode}]: ${aiData.hp} / ${aiData.max_hp}`;
            
            document.getElementById('player-level').textContent = playerData.level;
            document.getElementById('player-coins').textContent = playerData.coins + ' üí∞';
            
            const tierBadge = document.getElementById('player-tier');
            tierBadge.textContent = playerData.tier;
            tierBadge.style.backgroundColor = getTierColor(playerData.tier);
        }
        
        function getTierColor(tier) {
            const colors = {
                'Bronze': '#cd7f32',
                'Silver': '#c0c0c0',
                'Gold': '#ffd700',
                'Platinum': '#e5e4e2',
                'Diamond': '#b9f2ff',
                'Master': '#9d4edd',
                'Legend': '#ff006e'
            };
            return colors[tier] || '#cd7f32';
        }
        
        // ========== ÏïåÎ¶º ÌëúÏãú ==========
        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }
        
        // ========== Ïû•Ïï†Î¨º Ïï†ÎãàÎ©îÏù¥ÏÖò ==========
        function animateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.rotation.y += obstacle.userData.rotationSpeed || 0.01;
            });
        }
        
        // ========== ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à ==========
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ========== ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù ==========
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const difficulty = btn.getAttribute('data-difficulty');
                currentDifficulty = difficulty;
                
                // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // ÏÑúÎ≤ÑÏóê ÎÇúÏù¥ÎèÑ Î≥ÄÍ≤Ω ÏöîÏ≤≠
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify({
                        type: 'change_difficulty',
                        difficulty: difficulty
                    }));
                    
                    showNotification(`AI ÎÇúÏù¥ÎèÑ: ${difficulty.toUpperCase()}`, 1500);
                }
            });
        });
        
        // ========== ÏóÖÍ∑∏Î†àÏù¥Îìú ÌÅ¥Î¶≠ ==========
        document.querySelectorAll('.upgrade-item').forEach(item => {
            item.addEventListener('click', () => {
                const upgradeType = item.getAttribute('data-type');
                
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify({
                        type: 'upgrade',
                        upgrade_type: upgradeType
                    }));
                }
            });
        });
        
        // ========== Î©îÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ ==========
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            animateObstacles();
            updateExplosions();
            updateParticles();
            updateUI();
            
            frameCount++;
            
            renderer.render(scene, camera);
        }
        
        // ========== WebSocket Ïó∞Í≤∞ ==========
        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
            
            console.log('üîå WebSocket Ïó∞Í≤∞ ÏãúÎèÑ:', wsUrl);
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = () => {
                console.log('‚úÖ WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ!');
                isConnected = true;
                document.getElementById('status').style.borderColor = 'rgba(74, 222, 128, 0.7)';
                document.querySelector('.status-dot').className = 'status-dot green';
                document.getElementById('status-text').textContent = 'ÏÑúÎ≤Ñ Ïó∞Í≤∞Îê®';
            };
            
            websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                
                if (message.type === 'init') {
                    clientId = message.client_id;
                    aiDroneId = message.ai_drone_id;
                    
                    const pData = message.player_data;
                    playerData.hp = pData.hp;
                    playerData.max_hp = pData.max_hp;
                    playerData.level = pData.level;
                    playerData.exp = pData.experience;
                    playerData.coins = pData.coins;
                    playerData.tier = pData.tier.display;
                    playerData.position.x = pData.position[0];
                    playerData.position.y = pData.position[1];
                    playerData.position.z = pData.position[2];
                    
                    if (playerDrone) {
                        playerDrone.position.set(...pData.position);
                    }
                    
                    const aData = message.ai_data;
                    aiData.hp = aData.hp;
                    aiData.max_hp = aData.max_hp;
                    aiData.position = {
                        x: aData.position[0],
                        y: aData.position[1],
                        z: aData.position[2]
                    };
                    aiData.behavior_mode = aData.behavior_mode || 'aggressive';
                    
                    if (aiDrone) {
                        aiDrone.position.set(...aData.position);
                    }
                    
                    createObstacles(message.obstacles);
                    
                    document.getElementById('loading').style.display = 'none';
                    
                    showNotification(message.message);
                    
                } else if (message.type === 'ai_update') {
                    const aiState = message.ai_state;
                    if (aiDrone && aiState.position) {
                        aiDrone.position.set(...aiState.position);
                        
                        aiData.hp = aiState.hp;
                        aiData.max_hp = aiState.max_hp;
                        aiData.behavior_mode = aiState.behavior_mode || 'aggressive';
                        aiData.position = {
                            x: aiState.position[0],
                            y: aiState.position[1],
                            z: aiState.position[2]
                        };
                        
                        aiDrone.children.forEach(child => {
                            if (child.geometry && child.geometry.type === 'CylinderGeometry') {
                                child.rotation.y += child.userData.rotationSpeed || 0.4;
                            }
                        });
                        
                        if (aiState.velocity) {
                            aiDrone.rotation.z = -aiState.velocity[0] * 0.5;
                            aiDrone.rotation.x = aiState.velocity[2] * 0.5;
                        }
                    }
                    
                } else if (message.type === 'game_state') {
                    if (message.missiles) {
                        updateMissiles(message.missiles);
                    }
                    
                } else if (message.type === 'missile_fired') {
                    if (message.success && message.missile) {
                        createMissile(message.missile);
                    }
                    
                } else if (message.type === 'ai_missile_fired') {
                    if (message.missile) {
                        createMissile(message.missile);
                    }
                    
                } else if (message.type === 'damage_taken') {
                    playerData.hp = message.hp;
                    playerData.max_hp = message.max_hp;
                    
                    if (message.explosion_position) {
                        createExplosion(message.explosion_position);
                    }
                    
                    showNotification(`üí• -${message.damage} Îç∞ÎØ∏ÏßÄ!`, 1000);
                    
                } else if (message.type === 'obstacle_collision') {
                    playerData.hp = message.hp;
                    
                    if (message.explosion_position) {
                        createExplosion(message.explosion_position);
                    }
                    
                    showNotification(`‚ö†Ô∏è Ï∂©Îèå! -${message.damage} Îç∞ÎØ∏ÏßÄ!`, 1500);
                    
                    // Î∞òÎ∞ú ÏÜçÎèÑ Ï†ÅÏö©
                    if (message.bounce_velocity) {
                        playerData.velocity.x = message.bounce_velocity[0];
                        playerData.velocity.y = message.bounce_velocity[1];
                        playerData.velocity.z = message.bounce_velocity[2];
                    }
                    
                } else if (message.type === 'hit_confirmed') {
                    aiData.hp = message.target_hp;
                    aiData.max_hp = message.target_max_hp || 100;
                    
                    if (message.explosion_position) {
                        createExplosion(message.explosion_position);
                    }
                    
                    showNotification(`üéØ Î™ÖÏ§ë! -${message.damage}`, 1000);
                    
                } else if (message.type === 'kill_confirmed') {
                    const rewards = message.rewards;
                    playerData.coins = message.player_data.coins;
                    playerData.level = message.player_data.level;
                    playerData.exp = message.player_data.experience;
                    
                    document.getElementById('kill-count').textContent = rewards.session_kills;
                    document.getElementById('score-value').textContent = message.player_data.session.score;
                    
                    showNotification(`üî• ÌÇ¨! +${rewards.score_reward} Ï†êÏàò`, 2500);
                    
                } else if (message.type === 'player_died') {
                    showNotification('üíÄ ÏÇ¨Îßù! Î¶¨Ïä§Ìè∞ Ï§ë...', 3000);
                    
                } else if (message.type === 'respawned') {
                    const pData = message.player_data;
                    playerData.hp = pData.hp;
                    playerData.max_hp = pData.max_hp;
                    playerData.position = {
                        x: pData.position[0],
                        y: pData.position[1],
                        z: pData.position[2]
                    };
                    
                    if (playerDrone) {
                        playerDrone.position.set(...pData.position);
                    }
                    
                    showNotification(message.message, 2000);
                    
                } else if (message.type === 'ai_respawned') {
                    const aData = message.ai_data;
                    aiData.hp = aData.hp;
                    aiData.max_hp = aData.max_hp;
                    aiData.position = {
                        x: aData.position[0],
                        y: aData.position[1],
                        z: aData.position[2]
                    };
                    
                    if (aiDrone) {
                        aiDrone.position.set(...aData.position);
                    }
                    
                } else if (message.type === 'difficulty_changed') {
                    const aData = message.ai_data;
                    aiData.max_hp = aData.max_hp;
                    aiData.hp = aData.hp;
                    
                    showNotification(`ü§ñ AI ÎÇúÏù¥ÎèÑ: ${message.difficulty.toUpperCase()}`, 2000);
                    
                } else if (message.type === 'upgrade_result') {
                    if (message.success) {
                        const pData = message.player_data;
                        playerData.coins = pData.coins;
                        
                        showNotification(`‚ú® ÏóÖÍ∑∏Î†àÏù¥Îìú ÏôÑÎ£å!`, 1500);
                        
                        Object.keys(pData.upgrades).forEach(key => {
                            const upgrade = pData.upgrades[key];
                            const item = document.querySelector(`[data-type="${key}"]`);
                            if (item) {
                                item.querySelector('.upgrade-level').textContent = upgrade.level;
                                item.querySelector('.upgrade-cost').textContent = upgrade.cost + ' üí∞';
                                
                                if (!upgrade.can_upgrade) {
                                    item.classList.add('disabled');
                                } else {
                                    item.classList.remove('disabled');
                                }
                            }
                        });
                    } else {
                        const reasons = {
                            'max_level': 'ÏµúÎåÄ Î†àÎ≤®ÏûÖÎãàÎã§!',
                            'insufficient_coins': 'ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'
                        };
                        showNotification(`‚ùå ${reasons[message.reason] || 'Ïã§Ìå®'}`, 2000);
                    }
                }
            };
            
            websocket.onerror = (error) => {
                console.error('‚ùå WebSocket Ïò§Î•ò:', error);
            };
            
            websocket.onclose = () => {
                console.log('üîå WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
                isConnected = false;
                document.getElementById('status').style.borderColor = 'rgba(239, 68, 68, 0.7)';
                document.querySelector('.status-dot').className = 'status-dot red';
                document.getElementById('status-text').textContent = 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÎÅäÍπÄ';
                
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        // ========== Í≤åÏûÑ ÏãúÏûë ==========
        function startGame() {
            console.log('üéÆ Í≤åÏûÑ ÏãúÏûë! (Í≥†ÎèÑÌôî Î≤ÑÏ†Ñ)');
            initThreeJS();
            connectWebSocket();
            animate();
        }
        
        window.addEventListener('load', startGame);
    </script>
</body>
</html>
