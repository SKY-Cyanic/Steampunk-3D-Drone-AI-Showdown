<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš 3D ë“œë¡  AI ëŒ€ì „ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* HP ë°” ìŠ¤íƒ€ì¼ */
        .hp-bar-container {
            position: absolute;
            width: 300px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 5px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .hp-bar-fill {
            height: 100%;
            border-radius: 15px;
            transition: width 0.3s ease, background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #player-hp-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #ai-hp-bar {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* ì •ë³´ íŒ¨ë„ */
        #info-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            min-width: 280px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #info-panel h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4ade80;
            border-bottom: 2px solid #4ade80;
            padding-bottom: 5px;
        }
        
        .stat {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat .label {
            color: #94a3b8;
        }
        
        .stat .value {
            color: #4ade80;
            font-weight: bold;
        }
        
        /* í‹°ì–´ í‘œì‹œ */
        .tier-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        /* ë ˆë²¨ & ê²½í—˜ì¹˜ ë°” */
        .exp-bar-container {
            width: 100%;
            height: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .exp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s ease;
        }
        
        /* ì ìˆ˜ ë° í‚¬ íŒ¨ë„ */
        #score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            min-width: 200px;
        }
        
        #score-panel h2 {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .score-value {
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        /* ì—…ê·¸ë ˆì´ë“œ íŒ¨ë„ */
        #upgrade-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(147, 51, 234, 0.5);
            max-width: 300px;
        }
        
        #upgrade-panel h3 {
            color: #a78bfa;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .upgrade-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .upgrade-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .upgrade-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-cost {
            color: #ffd700;
            font-weight: bold;
        }
        
        /* ì¡°ì‘ë²• */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #60a5fa;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* ì¿¨ë‹¤ìš´ í‘œì‹œ */
        #cooldown-indicator {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 150px);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.8);
            border: 3px solid white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            z-index: 1000;
        }
        
        #cooldown-indicator.ready {
            background: rgba(74, 222, 128, 0.8);
        }
        
        /* ì•Œë¦¼ ë©”ì‹œì§€ */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            display: none;
            text-align: center;
            border: 3px solid #4ade80;
        }
        
        /* ë¡œë”© */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }
        
        /* ì—°ê²° ìƒíƒœ */
        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-300px);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-dot.green {
            background: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.8);
        }
        
        .status-dot.red {
            background: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="loading">ğŸš ê²Œì„ ë¡œë”© ì¤‘...</div>
        
        <!-- í”Œë ˆì´ì–´ HP ë°” -->
        <div id="player-hp-bar" class="hp-bar-container">
            <div class="hp-bar-fill" id="player-hp-fill" style="width: 100%; background: linear-gradient(90deg, #4ade80, #22c55e);">
                <span id="player-hp-text">100 / 100</span>
            </div>
        </div>
        
        <!-- AI HP ë°” -->
        <div id="ai-hp-bar" class="hp-bar-container">
            <div class="hp-bar-fill" id="ai-hp-fill" style="width: 100%; background: linear-gradient(90deg, #ef4444, #dc2626);">
                <span id="ai-hp-text">100 / 100</span>
            </div>
        </div>
        
        <!-- ì •ë³´ íŒ¨ë„ -->
        <div id="info-panel">
            <h2>ğŸ‘¤ í”Œë ˆì´ì–´ ì •ë³´</h2>
            <div class="stat">
                <span class="label">ë ˆë²¨:</span>
                <span class="value" id="player-level">1</span>
            </div>
            <div class="stat">
                <span class="label">í‹°ì–´:</span>
                <span class="tier-badge" id="player-tier">Bronze</span>
            </div>
            <div class="stat">
                <span class="label">ì½”ì¸:</span>
                <span class="value" id="player-coins">0 ğŸ’°</span>
            </div>
            <div class="exp-bar-container">
                <div class="exp-bar-fill" id="exp-bar" style="width: 0%;"></div>
            </div>
            <div class="stat" style="font-size: 11px; margin-top: 5px;">
                <span id="exp-text">0 / 100 EXP</span>
            </div>
        </div>
        
        <!-- ì ìˆ˜ íŒ¨ë„ -->
        <div id="score-panel">
            <h2>ğŸ† ì „íˆ¬ ê¸°ë¡</h2>
            <div class="stat">
                <span class="label">í‚¬:</span>
                <span class="value" id="kill-count">0</span>
            </div>
            <div class="stat">
                <span class="label">ì ìˆ˜:</span>
                <span class="score-value" id="score-value">0</span>
            </div>
        </div>
        
        <!-- ì—…ê·¸ë ˆì´ë“œ íŒ¨ë„ -->
        <div id="upgrade-panel">
            <h3>âš¡ ì—…ê·¸ë ˆì´ë“œ</h3>
            <div class="upgrade-item" data-type="speed">
                <span>ğŸš€ ì†ë„ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 ğŸ’°</span>
            </div>
            <div class="upgrade-item" data-type="armor">
                <span>ğŸ›¡ï¸ ë°©ì–´ë ¥ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 ğŸ’°</span>
            </div>
            <div class="upgrade-item" data-type="damage">
                <span>âš”ï¸ ê³µê²©ë ¥ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 ğŸ’°</span>
            </div>
            <div class="upgrade-item" data-type="fire_rate">
                <span>âš¡ ë°œì‚¬ì†ë„ Lv.<span class="upgrade-level">0</span></span>
                <span class="upgrade-cost">100 ğŸ’°</span>
            </div>
        </div>
        
        <!-- ì¡°ì‘ë²• -->
        <div id="controls">
            <h3>âŒ¨ï¸ ì¡°ì‘ë²•</h3>
            <div>
                <span class="key">W</span> ì „ì§„ |
                <span class="key">S</span> í›„ì§„ |
                <span class="key">A</span> ì¢Œì¸¡ |
                <span class="key">D</span> ìš°ì¸¡
            </div>
            <div style="margin-top: 8px;">
                <span class="key">Space</span> ìƒìŠ¹ |
                <span class="key">Shift</span> í•˜ê°•
            </div>
            <div style="margin-top: 8px;">
                <span class="key">F</span> ë¯¸ì‚¬ì¼ ë°œì‚¬ ğŸš€
            </div>
        </div>
        
        <!-- ì—°ê²° ìƒíƒœ -->
        <div id="status">
            <span class="status-dot red"></span>
            <span id="status-text">ì„œë²„ ì—°ê²° ì¤‘...</span>
        </div>
        
        <!-- ì¿¨ë‹¤ìš´ í‘œì‹œ -->
        <div id="cooldown-indicator">F</div>
        
        <!-- ì•Œë¦¼ -->
        <div id="notification"></div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== ì „ì—­ ë³€ìˆ˜ ==========
        let scene, camera, renderer;
        let playerDrone, aiDrone;
        let obstacles = [];
        let missiles = {};  // ë¯¸ì‚¬ì¼ ê°ì²´ë“¤
        let explosions = [];  // í­ë°œ ì´í™íŠ¸
        let websocket;
        let isConnected = false;
        let clientId, aiDroneId;
        
        // í”Œë ˆì´ì–´ ë°ì´í„°
        let playerData = {
            position: { x: 0, y: 10, z: 30 },
            velocity: { x: 0, y: 0, z: 0 },
            hp: 100,
            max_hp: 100,
            level: 1,
            exp: 0,
            coins: 0,
            tier: 'Bronze'
        };
        
        // AI ë°ì´í„°
        let aiData = {
            position: { x: -10, y: 10, z: -10 },
            hp: 100,
            max_hp: 100
        };
        
        // ê²Œì„ ì„¤ì •
        let keys = {};
        const MOVE_SPEED = 0.3;
        const MAX_SPEED = 1.0;
        const ACCELERATION = 0.05;
        const DRAG = 0.95;
        
        // FPS ì¸¡ì •
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // ========== Three.js ì´ˆê¸°í™” ==========
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 100);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 20, 40);
            camera.lookAt(0, 10, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight1 = new THREE.PointLight(0xff6b35, 2, 50);
            pointLight1.position.set(15, 15, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4ecdc4, 2, 50);
            pointLight2.position.set(-20, 15, -15);
            scene.add(pointLight2);
            
            // ë°”ë‹¥
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d3561,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const gridHelper = new THREE.GridHelper(100, 20, 0x4ecdc4, 0x2d3561);
            scene.add(gridHelper);
            
            // ë“œë¡  ìƒì„±
            createPlayerDrone();
            createAIDrone();
            
            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', onWindowResize);
            
            console.log('âœ… Three.js ì´ˆê¸°í™” ì™„ë£Œ!');
        }
        
        // ========== í”Œë ˆì´ì–´ ë“œë¡  ìƒì„± ==========
        function createPlayerDrone() {
            const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4ade80,
                emissive: 0x2dd4bf,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            const propellerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8);
            const propellerMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const propellerPositions = [
                { x: 1, z: 1 },
                { x: -1, z: 1 },
                { x: 1, z: -1 },
                { x: -1, z: -1 }
            ];
            
            playerDrone = new THREE.Group();
            playerDrone.add(body);
            
            propellerPositions.forEach(pos => {
                const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                propeller.position.set(pos.x, 0.4, pos.z);
                propeller.userData.rotationSpeed = Math.random() * 0.5 + 0.5;
                playerDrone.add(propeller);
            });
            
            playerDrone.position.set(playerData.position.x, playerData.position.y, playerData.position.z);
            scene.add(playerDrone);
        }
        
        // ========== AI ë“œë¡  ìƒì„± ==========
        function createAIDrone() {
            const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xef4444,
                emissive: 0xdc2626,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            const propellerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8);
            const propellerMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const propellerPositions = [
                { x: 1, z: 1 },
                { x: -1, z: 1 },
                { x: 1, z: -1 },
                { x: -1, z: -1 }
            ];
            
            aiDrone = new THREE.Group();
            aiDrone.add(body);
            
            propellerPositions.forEach(pos => {
                const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                propeller.position.set(pos.x, 0.4, pos.z);
                propeller.userData.rotationSpeed = Math.random() * 0.5 + 0.5;
                aiDrone.add(propeller);
            });
            
            aiDrone.position.set(aiData.position.x, aiData.position.y, aiData.position.z);
            scene.add(aiDrone);
        }
        
        // ========== ì¥ì• ë¬¼ ìƒì„± ==========
        function createObstacles(obstaclesData) {
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            
            obstaclesData.forEach(obsData => {
                let obstacle;
                
                if (obsData.type === 'gear') {
                    const geometry = new THREE.CylinderGeometry(
                        obsData.size[0], obsData.size[0], obsData.size[1], 16
                    );
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xb45309,
                        metalness: 0.9,
                        roughness: 0.3
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const toothGeometry = new THREE.BoxGeometry(0.3, obsData.size[1], 0.8);
                        const tooth = new THREE.Mesh(toothGeometry, material);
                        const radius = obsData.size[0] + 0.3;
                        tooth.position.set(
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        );
                        tooth.rotation.y = angle;
                        obstacle.add(tooth);
                    }
                    
                } else if (obsData.type === 'pipe') {
                    const geometry = new THREE.CylinderGeometry(
                        obsData.size[0], obsData.size[0], obsData.size[1], 8
                    );
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x475569,
                        metalness: 0.8,
                        roughness: 0.4
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    
                    if (obsData.rotation === 90) {
                        obstacle.rotation.z = Math.PI / 2;
                    }
                }
                
                obstacle.position.set(obsData.position[0], obsData.position[1], obsData.position[2]);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                obstacle.userData.rotationSpeed = Math.random() * 0.01 + 0.005;
                
                scene.add(obstacle);
                obstacles.push(obstacle);
            });
            
            console.log(`âœ… ${obstacles.length}ê°œì˜ ì¥ì• ë¬¼ ìƒì„± ì™„ë£Œ!`);
        }
        
        // ========== ë¯¸ì‚¬ì¼ ìƒì„± ==========
        function createMissile(missileData) {
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: missileData.owner_id.includes('ai') ? 0xef4444 : 0x4ade80,
                emissive: missileData.owner_id.includes('ai') ? 0xff0000 : 0x00ff00,
                emissiveIntensity: 0.5
            });
            
            const missile = new THREE.Mesh(geometry, material);
            missile.position.set(
                missileData.position[0],
                missileData.position[1],
                missileData.position[2]
            );
            
            // ê¼¬ë¦¬ íš¨ê³¼
            const tailGeometry = new THREE.ConeGeometry(0.15, 0.8, 8);
            const tailMaterial = new THREE.MeshBasicMaterial({
                color: missileData.owner_id.includes('ai') ? 0xff6666 : 0x66ff66,
                transparent: true,
                opacity: 0.6
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.rotation.x = Math.PI / 2;
            tail.position.z = -0.5;
            missile.add(tail);
            
            scene.add(missile);
            missiles[missileData.missile_id] = {
                mesh: missile,
                data: missileData
            };
        }
        
        // ========== í­ë°œ ì´í™íŠ¸ ==========
        function createExplosion(position) {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1.0
            });
            
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.set(position[0], position[1], position[2]);
            explosion.userData.life = 30;  // í”„ë ˆì„
            explosion.userData.maxLife = 30;
            
            scene.add(explosion);
            explosions.push(explosion);
        }
        
        // ========== ë¯¸ì‚¬ì¼ ì—…ë°ì´íŠ¸ ==========
        function updateMissiles(missilesList) {
            // ê¸°ì¡´ ë¯¸ì‚¬ì¼ê³¼ ìƒˆ ë¯¸ì‚¬ì¼ ë™ê¸°í™”
            const activeMissileIds = new Set(missilesList.map(m => m.missile_id));
            
            // ì‚­ì œëœ ë¯¸ì‚¬ì¼ ì œê±°
            for (const missileId in missiles) {
                if (!activeMissileIds.has(missileId)) {
                    scene.remove(missiles[missileId].mesh);
                    delete missiles[missileId];
                }
            }
            
            // ë¯¸ì‚¬ì¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            missilesList.forEach(missileData => {
                if (missiles[missileData.missile_id]) {
                    const missile = missiles[missileData.missile_id];
                    missile.mesh.position.set(
                        missileData.position[0],
                        missileData.position[1],
                        missileData.position[2]
                    );
                    
                    // íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                    missile.mesh.rotation.z += 0.2;
                } else {
                    createMissile(missileData);
                }
            });
        }
        
        // ========== í­ë°œ ì• ë‹ˆë©”ì´ì…˜ ==========
        function updateExplosions() {
            explosions.forEach((explosion, index) => {
                explosion.userData.life--;
                const progress = 1 - (explosion.userData.life / explosion.userData.maxLife);
                
                explosion.scale.set(1 + progress * 3, 1 + progress * 3, 1 + progress * 3);
                explosion.material.opacity = 1 - progress;
                
                if (explosion.userData.life <= 0) {
                    scene.remove(explosion);
                    explosions.splice(index, 1);
                }
            });
        }
        
        // ========== í‚¤ë³´ë“œ ì…ë ¥ ==========
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // Fí‚¤ë¡œ ë¯¸ì‚¬ì¼ ë°œì‚¬
            if (e.code === 'KeyF' && isConnected) {
                fireMissile();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // ========== ë¯¸ì‚¬ì¼ ë°œì‚¬ ==========
        function fireMissile() {
            // ë°œì‚¬ ë°©í–¥ ê³„ì‚° (AIë¥¼ í–¥í•´)
            const direction = [
                aiDrone.position.x - playerDrone.position.x,
                aiDrone.position.y - playerDrone.position.y,
                aiDrone.position.z - playerDrone.position.z
            ];
            
            // ì •ê·œí™”
            const length = Math.sqrt(direction[0]**2 + direction[1]**2 + direction[2]**2);
            if (length > 0) {
                direction[0] /= length;
                direction[1] /= length;
                direction[2] /= length;
            }
            
            websocket.send(JSON.stringify({
                type: 'fire_missile',
                direction: direction
            }));
        }
        
        // ========== í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸ ==========
        function updatePlayer() {
            // í‚¤ë³´ë“œ ì…ë ¥
            if (keys['KeyW']) playerData.velocity.z -= ACCELERATION;
            if (keys['KeyS']) playerData.velocity.z += ACCELERATION;
            if (keys['KeyA']) playerData.velocity.x -= ACCELERATION;
            if (keys['KeyD']) playerData.velocity.x += ACCELERATION;
            if (keys['Space']) playerData.velocity.y += ACCELERATION;
            if (keys['ShiftLeft'] || keys['ShiftRight']) playerData.velocity.y -= ACCELERATION;
            
            // ì†ë„ ì œí•œ
            const speed = Math.sqrt(
                playerData.velocity.x ** 2 + 
                playerData.velocity.y ** 2 + 
                playerData.velocity.z ** 2
            );
            if (speed > MAX_SPEED) {
                playerData.velocity.x = (playerData.velocity.x / speed) * MAX_SPEED;
                playerData.velocity.y = (playerData.velocity.y / speed) * MAX_SPEED;
                playerData.velocity.z = (playerData.velocity.z / speed) * MAX_SPEED;
            }
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            playerData.position.x += playerData.velocity.x;
            playerData.position.y += playerData.velocity.y;
            playerData.position.z += playerData.velocity.z;
            
            // ê²½ê³„ ì œí•œ
            playerData.position.x = Math.max(-50, Math.min(50, playerData.position.x));
            playerData.position.y = Math.max(2, Math.min(50, playerData.position.y));
            playerData.position.z = Math.max(-50, Math.min(50, playerData.position.z));
            
            // í•­ë ¥
            playerData.velocity.x *= DRAG;
            playerData.velocity.y *= DRAG;
            playerData.velocity.z *= DRAG;
            
            // ë“œë¡  ë©”ì‹œ ì—…ë°ì´íŠ¸
            if (playerDrone) {
                playerDrone.position.set(playerData.position.x, playerData.position.y, playerData.position.z);
                
                playerDrone.children.forEach(child => {
                    if (child.geometry && child.geometry.type === 'CylinderGeometry') {
                        child.rotation.y += child.userData.rotationSpeed || 0.3;
                    }
                });
                
                playerDrone.rotation.z = -playerData.velocity.x * 0.3;
                playerDrone.rotation.x = playerData.velocity.z * 0.3;
            }
            
            // ì¹´ë©”ë¼
            const cameraOffset = { x: 0, y: 15, z: 25 };
            camera.position.set(
                playerData.position.x + cameraOffset.x,
                playerData.position.y + cameraOffset.y,
                playerData.position.z + cameraOffset.z
            );
            camera.lookAt(playerData.position.x, playerData.position.y, playerData.position.z);
            
            // ì„œë²„ë¡œ ì „ì†¡
            if (isConnected && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'player_update',
                    position: [playerData.position.x, playerData.position.y, playerData.position.z],
                    velocity: [playerData.velocity.x, playerData.velocity.y, playerData.velocity.z]
                }));
            }
        }
        
        // ========== UI ì—…ë°ì´íŠ¸ ==========
        function updateUI() {
            // HP ë°”
            const playerHpPercent = (playerData.hp / playerData.max_hp) * 100;
            document.getElementById('player-hp-fill').style.width = playerHpPercent + '%';
            document.getElementById('player-hp-text').textContent = `${playerData.hp} / ${playerData.max_hp}`;
            
            // HP ë°” ìƒ‰ìƒ ë³€ê²½
            const playerHpFill = document.getElementById('player-hp-fill');
            if (playerHpPercent > 60) {
                playerHpFill.style.background = 'linear-gradient(90deg, #4ade80, #22c55e)';
            } else if (playerHpPercent > 30) {
                playerHpFill.style.background = 'linear-gradient(90deg, #fbbf24, #f59e0b)';
            } else {
                playerHpFill.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
            }
            
            const aiHpPercent = (aiData.hp / aiData.max_hp) * 100;
            document.getElementById('ai-hp-fill').style.width = aiHpPercent + '%';
            document.getElementById('ai-hp-text').textContent = `AI: ${aiData.hp} / ${aiData.max_hp}`;
            
            // ë ˆë²¨ & ê²½í—˜ì¹˜
            document.getElementById('player-level').textContent = playerData.level;
            document.getElementById('player-coins').textContent = playerData.coins + ' ğŸ’°';
            
            // í‹°ì–´
            const tierBadge = document.getElementById('player-tier');
            tierBadge.textContent = playerData.tier;
            tierBadge.style.backgroundColor = getTierColor(playerData.tier);
        }
        
        function getTierColor(tier) {
            const colors = {
                'Bronze': '#cd7f32',
                'Silver': '#c0c0c0',
                'Gold': '#ffd700',
                'Platinum': '#e5e4e2',
                'Diamond': '#b9f2ff',
                'Master': '#9d4edd',
                'Legend': '#ff006e'
            };
            return colors[tier] || '#cd7f32';
        }
        
        // ========== ì•Œë¦¼ í‘œì‹œ ==========
        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }
        
        // ========== ì¥ì• ë¬¼ ì• ë‹ˆë©”ì´ì…˜ ==========
        function animateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.rotation.y += obstacle.userData.rotationSpeed || 0.01;
            });
        }
        
        // ========== ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ==========
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ========== ì—…ê·¸ë ˆì´ë“œ í´ë¦­ ==========
        document.querySelectorAll('.upgrade-item').forEach(item => {
            item.addEventListener('click', () => {
                const upgradeType = item.getAttribute('data-type');
                
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify({
                        type: 'upgrade',
                        upgrade_type: upgradeType
                    }));
                }
            });
        });
        
        // ========== ë©”ì¸ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ==========
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            animateObstacles();
            updateExplosions();
            updateUI();
            
            renderer.render(scene, camera);
        }
        
        // ========== WebSocket ì—°ê²° ==========
        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
            
            console.log('ğŸ”Œ WebSocket ì—°ê²° ì‹œë„:', wsUrl);
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = () => {
                console.log('âœ… WebSocket ì—°ê²° ì„±ê³µ!');
                isConnected = true;
                document.getElementById('status').style.borderColor = 'rgba(74, 222, 128, 0.5)';
                document.querySelector('.status-dot').className = 'status-dot green';
                document.getElementById('status-text').textContent = 'ì„œë²„ ì—°ê²°ë¨';
            };
            
            websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                
                if (message.type === 'init') {
                    clientId = message.client_id;
                    aiDroneId = message.ai_drone_id;
                    
                    // í”Œë ˆì´ì–´ ë°ì´í„° ì´ˆê¸°í™”
                    const pData = message.player_data;
                    playerData.hp = pData.hp;
                    playerData.max_hp = pData.max_hp;
                    playerData.level = pData.level;
                    playerData.exp = pData.experience;
                    playerData.coins = pData.coins;
                    playerData.tier = pData.tier.display;
                    
                    // AI ë°ì´í„° ì´ˆê¸°í™”
                    const aData = message.ai_data;
                    aiData.hp = aData.hp;
                    aiData.max_hp = aData.max_hp;
                    aiData.position = {
                        x: aData.position[0],
                        y: aData.position[1],
                        z: aData.position[2]
                    };
                    
                    // ì¥ì• ë¬¼ ìƒì„±
                    createObstacles(message.obstacles);
                    
                    // ë¡œë”© í™”ë©´ ì œê±°
                    document.getElementById('loading').style.display = 'none';
                    
                    showNotification(message.message);
                    
                } else if (message.type === 'ai_update') {
                    const aiState = message.ai_state;
                    if (aiDrone && aiState.position) {
                        aiDrone.position.set(
                            aiState.position[0],
                            aiState.position[1],
                            aiState.position[2]
                        );
                        
                        aiData.hp = aiState.hp;
                        aiData.max_hp = aiState.max_hp;
                        aiData.position = {
                            x: aiState.position[0],
                            y: aiState.position[1],
                            z: aiState.position[2]
                        };
                        
                        aiDrone.children.forEach(child => {
                            if (child.geometry && child.geometry.type === 'CylinderGeometry') {
                                child.rotation.y += child.userData.rotationSpeed || 0.3;
                            }
                        });
                        
                        if (aiState.velocity) {
                            aiDrone.rotation.z = -aiState.velocity[0] * 0.5;
                            aiDrone.rotation.x = aiState.velocity[2] * 0.5;
                        }
                    }
                    
                } else if (message.type === 'game_state') {
                    // ë¯¸ì‚¬ì¼ ì—…ë°ì´íŠ¸
                    if (message.missiles) {
                        updateMissiles(message.missiles);
                    }
                    
                } else if (message.type === 'missile_fired') {
                    if (message.success) {
                        console.log('ë¯¸ì‚¬ì¼ ë°œì‚¬ ì„±ê³µ!');
                        if (message.missile) {
                            createMissile(message.missile);
                        }
                    }
                    
                } else if (message.type === 'ai_missile_fired') {
                    if (message.missile) {
                        createMissile(message.missile);
                    }
                    
                } else if (message.type === 'damage_taken') {
                    playerData.hp = message.hp;
                    playerData.max_hp = message.max_hp;
                    
                    // í­ë°œ ì´í™íŠ¸
                    if (message.explosion_position) {
                        createExplosion(message.explosion_position);
                    }
                    
                    showNotification(`-${message.damage} ë°ë¯¸ì§€!`, 1000);
                    
                } else if (message.type === 'hit_confirmed') {
                    // ëª…ì¤‘ í™•ì¸
                    aiData.hp = message.target_hp;
                    
                    if (message.explosion_position) {
                        createExplosion(message.explosion_position);
                    }
                    
                    showNotification(`ëª…ì¤‘! -${message.damage}`, 1000);
                    
                } else if (message.type === 'kill_confirmed') {
                    // í‚¬ í™•ì¸
                    const rewards = message.rewards;
                    playerData.coins = message.player_data.coins;
                    playerData.level = message.player_data.level;
                    playerData.exp = message.player_data.experience;
                    
                    document.getElementById('kill-count').textContent = rewards.session_kills;
                    document.getElementById('score-value').textContent = message.player_data.session.score;
                    
                    showNotification(`ğŸ¯ í‚¬! +${rewards.score_reward} ì ìˆ˜`, 2000);
                    
                } else if (message.type === 'player_died') {
                    showNotification('ğŸ’€ ì‚¬ë§! ë¦¬ìŠ¤í° ì¤‘...', 3000);
                    
                } else if (message.type === 'respawned') {
                    const pData = message.player_data;
                    playerData.hp = pData.hp;
                    playerData.max_hp = pData.max_hp;
                    playerData.position = {
                        x: pData.position[0],
                        y: pData.position[1],
                        z: pData.position[2]
                    };
                    
                    showNotification(message.message, 2000);
                    
                } else if (message.type === 'ai_respawned') {
                    const aData = message.ai_data;
                    aiData.hp = aData.hp;
                    aiData.max_hp = aData.max_hp;
                    
                } else if (message.type === 'upgrade_result') {
                    if (message.success) {
                        const pData = message.player_data;
                        playerData.coins = pData.coins;
                        
                        showNotification(`âœ¨ ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!`, 1500);
                        
                        // UI ì—…ë°ì´íŠ¸
                        Object.keys(pData.upgrades).forEach(key => {
                            const upgrade = pData.upgrades[key];
                            const item = document.querySelector(`[data-type="${key}"]`);
                            if (item) {
                                item.querySelector('.upgrade-level').textContent = upgrade.level;
                                item.querySelector('.upgrade-cost').textContent = upgrade.cost + ' ğŸ’°';
                                
                                if (!upgrade.can_upgrade) {
                                    item.classList.add('disabled');
                                }
                            }
                        });
                    } else {
                        showNotification(`âŒ ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨: ${message.reason}`, 2000);
                    }
                }
            };
            
            websocket.onerror = (error) => {
                console.error('âŒ WebSocket ì˜¤ë¥˜:', error);
            };
            
            websocket.onclose = () => {
                console.log('ğŸ”Œ WebSocket ì—°ê²° ì¢…ë£Œ');
                isConnected = false;
                document.getElementById('status').style.borderColor = 'rgba(239, 68, 68, 0.5)';
                document.querySelector('.status-dot').className = 'status-dot red';
                document.getElementById('status-text').textContent = 'ì„œë²„ ì—°ê²° ëŠê¹€';
                
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        // ========== ê²Œì„ ì‹œì‘ ==========
        function startGame() {
            console.log('ğŸ® ê²Œì„ ì‹œì‘!');
            initThreeJS();
            connectWebSocket();
            animate();
        }
        
        window.addEventListener('load', startGame);
    </script>
</body>
</html>
